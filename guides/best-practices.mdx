---
title: "Best Practices"
description: "Optimize your integration with the Yirifi.ai API using these proven strategies"
---

# Best Practices

This guide provides proven strategies and recommendations for building robust, efficient, and maintainable integrations with the Yirifi.ai API.

## Authentication & Security

### Store API Keys Securely

<Warning>
Never hardcode API keys in your application code or commit them to version control.
</Warning>

<CodeGroup>
```javascript Environment Variables
// Good: Use environment variables
const apiKey = process.env.YIRIFI_API_KEY;

// Bad: Hardcoded API key
const apiKey = 'yk_123456789abcdef'; // Never do this!
```

```python Environment Variables
import os

# Good: Use environment variables
api_key = os.environ.get('YIRIFI_API_KEY')

# Bad: Hardcoded API key
api_key = 'yk_123456789abcdef'  # Never do this!
```
</CodeGroup>

### Rotate API Keys Regularly

<Steps>
  <Step title="Generate new key">
    Create a new API key in your dashboard
  </Step>
  <Step title="Update applications">
    Deploy the new key to all your applications
  </Step>
  <Step title="Verify functionality">
    Test that all integrations work with the new key
  </Step>
  <Step title="Revoke old key">
    Once confirmed, revoke the old API key
  </Step>
</Steps>

### Use HTTPS Always

Always use HTTPS when making API requests to ensure data encryption in transit:

```javascript
// Good: HTTPS endpoint
const response = await fetch('https://api.yirifi.ai/v1/category', options);

// Bad: HTTP endpoint (insecure)
const response = await fetch('http://api.yirifi.ai/v1/category', options);
```

## Request Optimization

### Implement Caching

Cache API responses to reduce unnecessary requests:

<CodeGroup>
```javascript In-Memory Cache
class APICache {
  constructor(ttl = 300000) { // 5 minutes default
    this.cache = new Map();
    this.ttl = ttl;
  }

  get(key) {
    const item = this.cache.get(key);
    if (item && Date.now() - item.timestamp < this.ttl) {
      return item.data;
    }
    this.cache.delete(key);
    return null;
  }

  set(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  clear() {
    this.cache.clear();
  }
}

// Usage
const cache = new APICache();

async function getCategoriesWithCache() {
  const cacheKey = 'categories';
  let categories = cache.get(cacheKey);
  
  if (!categories) {
    const response = await fetch('https://api.yirifi.ai/v1/category', {
      headers: { 'Authorization': `Bearer ${apiKey}` }
    });
    categories = await response.json();
    cache.set(cacheKey, categories);
  }
  
  return categories;
}
```

```python Redis Cache
import redis
import json
import time

class APICache:
    def __init__(self, redis_client, ttl=300):
        self.redis = redis_client
        self.ttl = ttl

    def get(self, key):
        data = self.redis.get(key)
        return json.loads(data) if data else None

    def set(self, key, data):
        self.redis.setex(key, self.ttl, json.dumps(data))

# Usage
cache = APICache(redis.Redis(host='localhost', port=6379))

def get_categories_with_cache():
    cache_key = 'categories'
    categories = cache.get(cache_key)
    
    if not categories:
        response = requests.get(
            'https://api.yirifi.ai/v1/category',
            headers={'Authorization': f'Bearer {api_key}'}
        )
        categories = response.json()
        cache.set(cache_key, categories)
    
    return categories
```
</CodeGroup>

### Batch Requests When Possible

Instead of making multiple individual requests, batch them when the API supports it:

<CodeGroup>
```javascript Batching
// Less efficient: Multiple individual requests
const categories = await Promise.all([
  fetch('https://api.yirifi.ai/v1/category/1'),
  fetch('https://api.yirifi.ai/v1/category/2'),
  fetch('https://api.yirifi.ai/v1/category/3')
]);

// More efficient: Single batch request (if supported)
const batchResponse = await fetch('https://api.yirifi.ai/v1/category/batch', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ ids: ['1', '2', '3'] })
});
```

```python Batching
# Less efficient: Multiple requests
categories = []
for cat_id in ['1', '2', '3']:
    response = requests.get(f'https://api.yirifi.ai/v1/category/{cat_id}')
    categories.append(response.json())

# More efficient: Single batch request
batch_response = requests.post(
    'https://api.yirifi.ai/v1/category/batch',
    headers={'Authorization': f'Bearer {api_key}'},
    json={'ids': ['1', '2', '3']}
)
categories = batch_response.json()
```
</CodeGroup>

### Use Pagination Efficiently

When dealing with large datasets, implement efficient pagination:

<CodeGroup>
```javascript Efficient Pagination
async function getAllCategories() {
  const allCategories = [];
  let page = 1;
  let hasMore = true;

  while (hasMore) {
    const response = await fetch(`https://api.yirifi.ai/v1/category?page=${page}&limit=100`, {
      headers: { 'Authorization': `Bearer ${apiKey}` }
    });
    
    const data = await response.json();
    allCategories.push(...data.items);
    
    hasMore = data.hasMore;
    page++;
    
    // Add small delay to respect rate limits
    if (hasMore) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  return allCategories;
}
```

```python Efficient Pagination
def get_all_categories():
    all_categories = []
    page = 1
    has_more = True

    while has_more:
        response = requests.get(
            'https://api.yirifi.ai/v1/category',
            params={'page': page, 'limit': 100},
            headers={'Authorization': f'Bearer {api_key}'}
        )
        
        data = response.json()
        all_categories.extend(data['items'])
        
        has_more = data['hasMore']
        page += 1
        
        # Small delay to respect rate limits
        if has_more:
            time.sleep(0.1)

    return all_categories
```
</CodeGroup>

## Error Handling & Resilience

### Implement Retry Logic with Exponential Backoff

<CodeGroup>
```javascript Retry with Backoff
async function apiRequestWithRetry(url, options, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (response.status === 429) {
        // Rate limited - use Retry-After header if available
        const retryAfter = parseInt(response.headers.get('Retry-After')) || Math.pow(2, attempt);
        console.log(`Rate limited. Retrying after ${retryAfter} seconds...`);
        await sleep(retryAfter * 1000);
        continue;
      }
      
      if (response.status >= 500) {
        // Server error - retry with exponential backoff
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s
          console.log(`Server error. Retrying in ${delay}ms...`);
          await sleep(delay);
          continue;
        }
      }
      
      return response;
    } catch (error) {
      if (attempt === maxRetries) throw error;
      
      const delay = Math.pow(2, attempt) * 1000;
      console.log(`Request failed. Retrying in ${delay}ms...`);
      await sleep(delay);
    }
  }
}

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
```

```python Retry with Backoff
import time
import random
from functools import wraps

def retry_with_backoff(max_retries=3, backoff_factor=2):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_retries + 1):
                try:
                    response = func(*args, **kwargs)
                    
                    if response.status_code == 429:
                        # Rate limited
                        retry_after = int(response.headers.get('Retry-After', backoff_factor ** attempt))
                        print(f"Rate limited. Retrying after {retry_after} seconds...")
                        time.sleep(retry_after)
                        continue
                    
                    if response.status_code >= 500:
                        # Server error
                        if attempt < max_retries:
                            delay = (backoff_factor ** attempt) + random.uniform(0, 1)
                            print(f"Server error. Retrying in {delay:.1f} seconds...")
                            time.sleep(delay)
                            continue
                    
                    return response
                    
                except requests.RequestException as e:
                    if attempt == max_retries:
                        raise e
                    
                    delay = (backoff_factor ** attempt) + random.uniform(0, 1)
                    print(f"Request failed. Retrying in {delay:.1f} seconds...")
                    time.sleep(delay)
            
            return None
        return wrapper
    return decorator

# Usage
@retry_with_backoff(max_retries=3)
def make_api_request(url, headers):
    return requests.get(url, headers=headers)
```
</CodeGroup>

### Implement Circuit Breaker Pattern

Prevent cascading failures by implementing a circuit breaker:

<CodeGroup>
```javascript Circuit Breaker
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.threshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  async call(operation) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
    }
  }
}

// Usage
const circuitBreaker = new CircuitBreaker();

async function safeApiCall() {
  return circuitBreaker.call(async () => {
    const response = await fetch('https://api.yirifi.ai/v1/category', {
      headers: { 'Authorization': `Bearer ${apiKey}` }
    });
    return response.json();
  });
}
```
</CodeGroup>

## Performance Optimization

### Monitor API Usage

Track your API usage and performance:

<CodeGroup>
```javascript Usage Monitoring
class APIMonitor {
  constructor() {
    this.metrics = {
      requests: 0,
      errors: 0,
      totalResponseTime: 0,
      rateLimits: 0
    };
  }

  async trackRequest(requestFn) {
    const startTime = Date.now();
    this.metrics.requests++;

    try {
      const response = await requestFn();
      
      if (response.status === 429) {
        this.metrics.rateLimits++;
      }
      
      this.metrics.totalResponseTime += Date.now() - startTime;
      return response;
    } catch (error) {
      this.metrics.errors++;
      throw error;
    }
  }

  getStats() {
    return {
      ...this.metrics,
      averageResponseTime: this.metrics.totalResponseTime / this.metrics.requests,
      errorRate: this.metrics.errors / this.metrics.requests,
      rateLimitRate: this.metrics.rateLimits / this.metrics.requests
    };
  }

  reset() {
    this.metrics = {
      requests: 0,
      errors: 0,
      totalResponseTime: 0,
      rateLimits: 0
    };
  }
}

// Usage
const monitor = new APIMonitor();

async function monitoredApiCall(url, options) {
  return monitor.trackRequest(() => fetch(url, options));
}

// Check stats periodically
setInterval(() => {
  console.log('API Stats:', monitor.getStats());
}, 60000); // Every minute
```

```python Usage Monitoring
import time
from dataclasses import dataclass
from typing import Callable, Any

@dataclass
class APIMetrics:
    requests: int = 0
    errors: int = 0
    total_response_time: float = 0
    rate_limits: int = 0

class APIMonitor:
    def __init__(self):
        self.metrics = APIMetrics()

    def track_request(self, request_fn: Callable) -> Any:
        start_time = time.time()
        self.metrics.requests += 1

        try:
            response = request_fn()
            
            if response.status_code == 429:
                self.metrics.rate_limits += 1
            
            self.metrics.total_response_time += time.time() - start_time
            return response
        except Exception as e:
            self.metrics.errors += 1
            raise e

    def get_stats(self) -> dict:
        return {
            'requests': self.metrics.requests,
            'errors': self.metrics.errors,
            'rate_limits': self.metrics.rate_limits,
            'average_response_time': (
                self.metrics.total_response_time / self.metrics.requests 
                if self.metrics.requests > 0 else 0
            ),
            'error_rate': (
                self.metrics.errors / self.metrics.requests 
                if self.metrics.requests > 0 else 0
            )
        }

# Usage
monitor = APIMonitor()

def monitored_api_call(url, **kwargs):
    return monitor.track_request(lambda: requests.get(url, **kwargs))
```
</CodeGroup>

### Optimize Data Transfer

Minimize bandwidth usage by requesting only necessary fields:

```javascript
// Good: Request only needed fields
const response = await fetch('https://api.yirifi.ai/v1/category?fields=id,name', {
  headers: { 'Authorization': `Bearer ${apiKey}` }
});

// Less efficient: Request all fields
const response = await fetch('https://api.yirifi.ai/v1/category', {
  headers: { 'Authorization': `Bearer ${apiKey}` }
});
```

## Data Management

### Implement Data Validation

Always validate data before sending to the API:

<CodeGroup>
```javascript Data Validation
function validateCategoryData(data) {
  const errors = [];

  if (!data.name || typeof data.name !== 'string') {
    errors.push('Name is required and must be a string');
  }

  if (data.name && data.name.length < 3) {
    errors.push('Name must be at least 3 characters long');
  }

  if (data.description && typeof data.description !== 'string') {
    errors.push('Description must be a string');
  }

  if (errors.length > 0) {
    throw new ValidationError(errors);
  }

  return true;
}

async function createCategory(categoryData) {
  // Validate before sending
  validateCategoryData(categoryData);
  
  const response = await fetch('https://api.yirifi.ai/v1/category', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(categoryData)
  });

  return response.json();
}
```

```python Data Validation
from typing import Dict, List
import re

class ValidationError(Exception):
    def __init__(self, errors: List[str]):
        self.errors = errors
        super().__init__(f"Validation failed: {', '.join(errors)}")

def validate_category_data(data: Dict) -> bool:
    errors = []

    # Check required fields
    if 'name' not in data or not isinstance(data['name'], str):
        errors.append('Name is required and must be a string')

    # Check name length
    if 'name' in data and len(data['name']) < 3:
        errors.append('Name must be at least 3 characters long')

    # Check description if provided
    if 'description' in data and not isinstance(data['description'], str):
        errors.append('Description must be a string')

    if errors:
        raise ValidationError(errors)

    return True

def create_category(category_data: Dict):
    # Validate before sending
    validate_category_data(category_data)
    
    response = requests.post(
        'https://api.yirifi.ai/v1/category',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json=category_data
    )
    
    return response.json()
```
</CodeGroup>

### Handle Data Consistency

When working with related resources, ensure data consistency:

<CodeGroup>
```javascript Data Consistency
class CategoryManager {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.cache = new Map();
  }

  async createCategoryWithTemplates(categoryData, templates) {
    let createdCategory = null;
    const createdTemplates = [];

    try {
      // Create category first
      createdCategory = await this.createCategory(categoryData);
      
      // Create templates
      for (const template of templates) {
        template.categoryId = createdCategory.id;
        const createdTemplate = await this.createTemplate(template);
        createdTemplates.push(createdTemplate);
      }

      return {
        category: createdCategory,
        templates: createdTemplates
      };
    } catch (error) {
      // Rollback on failure
      await this.rollback(createdCategory, createdTemplates);
      throw error;
    }
  }

  async rollback(category, templates) {
    // Clean up created resources
    for (const template of templates) {
      try {
        await this.deleteTemplate(template.id);
      } catch (e) {
        console.error('Failed to rollback template:', e);
      }
    }

    if (category) {
      try {
        await this.deleteCategory(category.id);
      } catch (e) {
        console.error('Failed to rollback category:', e);
      }
    }
  }
}
```
</CodeGroup>

## Testing

### Mock API Responses for Testing

<CodeGroup>
```javascript Jest Mocking
// __mocks__/yirifi-api.js
export class YirifiAPI {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }

  async getCategories() {
    return [
      { id: '1', name: 'Test Category', description: 'Test description' }
    ];
  }

  async createCategory(data) {
    return { id: '123', ...data, createdAt: new Date().toISOString() };
  }
}

// In your tests
import { YirifiAPI } from '../yirifi-api';

jest.mock('../yirifi-api');

test('should create category', async () => {
  const api = new YirifiAPI('test-key');
  const result = await api.createCategory({ name: 'Test' });
  
  expect(result.id).toBe('123');
  expect(result.name).toBe('Test');
});
```

```python Python Mocking
# test_api.py
import pytest
from unittest.mock import Mock, patch
import requests

@patch('requests.get')
def test_get_categories(mock_get):
    # Mock the response
    mock_response = Mock()
    mock_response.json.return_value = [
        {'id': '1', 'name': 'Test Category'}
    ]
    mock_response.status_code = 200
    mock_get.return_value = mock_response
    
    # Test your function
    result = get_categories()
    
    assert len(result) == 1
    assert result[0]['name'] == 'Test Category'
    mock_get.assert_called_once()
```
</CodeGroup>

## Documentation

### Document Your Integration

Keep comprehensive documentation of your integration:

```markdown
# Yirifi.ai Integration Documentation

## Overview
This integration synchronizes category data between our system and Yirifi.ai.

## Configuration
- API Key: Set via `YIRIFI_API_KEY` environment variable
- Base URL: https://api.yirifi.ai/v1
- Rate Limits: 100 requests/minute

## Error Handling
- 401 Errors: Check API key configuration
- 429 Errors: Automatic retry with exponential backoff
- 500 Errors: Alert operations team

## Monitoring
- Response time alerts: > 5 seconds
- Error rate alerts: > 5%
- Rate limit alerts: > 80% of limit

## Testing
Run integration tests: `npm run test:integration`
```

## Security Checklist

<AccordionGroup>
  <Accordion title="API Key Management">
    - [ ] API keys stored in environment variables
    - [ ] API keys not in version control
    - [ ] Regular key rotation schedule
    - [ ] Different keys for different environments
  </Accordion>
  
  <Accordion title="Network Security">
    - [ ] Always use HTTPS
    - [ ] Validate SSL certificates
    - [ ] Implement request/response logging
    - [ ] Use webhook signature verification
  </Accordion>
  
  <Accordion title="Data Handling">
    - [ ] Validate all input data
    - [ ] Sanitize data before processing
    - [ ] Implement proper error handling
    - [ ] Log security events
  </Accordion>
</AccordionGroup>

By following these best practices, you'll build a robust, secure, and efficient integration with the Yirifi.ai API that scales with your application's needs.